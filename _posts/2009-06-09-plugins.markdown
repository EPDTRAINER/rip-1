---
layout: default
title: Writing Rip Plugins
class: plugins
---

Writing Rip Plugins
===================

Rip allows you to easily add your own first class commands. On launch, Rip 
will load any Ruby files in either `~/.rip/rip-commands` or 
`lib/rip/commands` within the current ripenv.

Let's say we wanted to create a `rip reverse` command, which reverses
all the installed package names. First we'll make the following directory
structure:

    reverse/
      README.markdown
      lib/
        rip/ 
          commands/
            reverse.rb
            
Our `reverse.rb` might look something like this:

{% highlight ruby %}
module Rip
  module Commands
    def reverse(*args)
      puts "ripenv: #{Rip::Env.active}", ''
      manager.packages.each do |package|
        puts package.to_s.reverse
      end
    end
  end
end
{% endhighlight %}

Great. Now let's make a temporary ripenv to test this out on:

    $ rip env create test_reverse

And finally, install this new command:
  
    $ rip install reverse
    
Now:

    $ rip reverse
    ripenv: test_reverse

    esrever
    
Victory! But let's say we want to reverse any word passed in
to `rip reverse`. No problem. We'll modify our reverse.rb to look
like this:

{% highlight ruby %}
module Rip
  module Commands
    def reverse(options = {}, package = nil, *args)
      puts "ripenv: #{Rip::Env.active}", ''        
      if package
        puts package.reverse
      else
        manager.packages.each do |package|
          puts package.to_s.reverse
        end
      end
    end
  end
end
{% endhighlight %}

We can reinstall our reverse project like so:

    $ rip install reverse -f

And try it out:

    $ rip reverse chris
    ripenv: base
    sirhc

Wonderful. As you can see, commands are just instance methods on 
Rip::Commands that take an options hash as a first parameter then a
splat of the args passed to the command line.

Here's a simple debug, for exploring:

{% highlight ruby %}
module Rip::Commands
  def debug(options, *args)
    puts "options: #{options.inspect}"
    puts "args: #{args.inspect}"
  end
end
{% endhighlight %}

Install that then have at:

    $ rip debug
    options: {}
    args: []
    $ rip debug -f chris
    options: {:f=>true}
    args: ["chris"]
    $ rip debug -f=chris
    options: {:f=>"chris"}
    args: []
    $ rip debug --name=chris more args
    options: {:name=>"chris"}
    args: ["more", "args"]

You get the idea.
