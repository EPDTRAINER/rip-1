#!/usr/bin/env ruby
# Usage: rip-package URL
#
# Downloads the package at URL to $RIPDIR/.packages using the appropriate
# transfer mechanism. Stores the package as PACKAGE-md5 where md5 is
# the hash of the URL from which it was retrieved.
#
# Prints the full path to the fetched package to standard out.
#
# Accepted transports:
#   git
#   hg
#   bzr
#   svn
#   curl + tar xzf
#   curl + tar xjf
#
# Works like this:
#
#  rip-package git://github/foo.git v1.0
#  |-- rip-fetch git://github/foo.git
#  |-- rip-unpack .rip/.cache/foo-123abc
#  |-- rip-build .rip/.packages/foo-123abc
#  |-- (Write rip metadata to package dir)
#  `-- return .rip/.packages/foo-123abc

require 'rip/script'

target = ARGV[0]

if ARGV[1] =~ /^\//
  path    = ARGV[1]
  version = ARGV[2]
else
  path    = "/"
  version = ARGV[1]
end

warn "packaging #{ARGV * ' '}"


if path == "/"
  # TODO: Eventually search load path for all rip-handle-*
  types = %w( git gem )

  types.each do |type|
    out = `rip-package-#{type} #{target} #{version}`

    if $?.exitstatus == 3
      next
    elsif $?.success?
      package_path = out.chomp
      package_path = sh "rip-build #{package_path}"
      puts package_path
      exit 0
    else
      exit $?.exitstatus
    end
  end
else
  base_package = sh "rip-package #{target} #{version}"
  if !File.exist?("#{base_package}#{path}")
    abort "#{target} #{path} does not exist"
  end

  name, hash = File.basename(base_package).split("-")
  package_path = "#{Rip.packages}/#{name}-#{Rip.md5("#{hash}#{path}")}"
  if !File.exist?(package_path)
    ln_s "#{base_package}#{path}", package_path
  end
  puts package_path
end
