#!/usr/bin/env ruby
# Usage: rip-package-gem NAME VERSION

require 'rip/script'

source, path, version = Rip::Package.parse_args(ARGV)

# Only handle root packages
exit 3 if path != '/'

unless source =~ /\.gem$/ || source =~ /^(\w|-)+$/
  exit 3 # Can't handle source
end


def list(name)
  rpg_available? ? rpg_list(name) : gem_list(name)
end

def unpack(name, version)
  info "fetching #{name} #{version}"
  rpg_available? ? rpg_unpack(name, version) : gem_unpack(name, version)
end

def dependencies(name, version)
  if rpg_available?
    rpg_dependencies(name, version)
  else
    gem_dependencies(name, version)
  end
end

def dep_line(name, tweedle, version)
  if version == '0'
    name
  elsif tweedle == '='
    "#{name} #{version}"
  else
    "#{name} #{tweedle}#{version}"
  end
end

def gem_list(name)
  gems = gem("list #{name} --remote").split("\n")
  if gems.detect { |f| f =~ /^#{name} \((.+)\)/ }
    $1
  end
end

def gem_unpack(name, version)
  path = gem_path = nil

  cd Rip.cache do
    begin
      if gem("fetch", name, "-v #{version}") =~ /Downloaded (.+)/
        gem_path = File.expand_path($1) + ".gem"
      else
        gem = name.dup
        gem << " #{version}" if version
        abort "#{gem} not found"
      end

      sh("gem unpack '#{gem_path}' --target='#{Rip.packages}'") =~
        /^Unpacked gem: '(.+)'$/
      path = $1
    ensure
      rm_rf gem_path if File.exist?(gem_path.to_s)
    end
  end

  if path.nil?
    abort "#{name} #{version} not found"
  end

  path
end

def gem_dependencies(name, version)
  deps = gem("dependency --pipe -r /^#{name}$/ -v #{version}")
  return [] if deps =~ /^No gems found/

  deps.split("\n").map do |dep|
    if dep =~ /(\S+) --version '(\S+) (\S+?)'/
      dep_line($1, $2, $3)
    end
  end
end

def rpg_list(name)
  if rpg("list -a #{name}") =~ /^#{name} (.+)$/
    $1
  end
end

def rpg_unpack(name, version)
  if path = rpg("unpack", name, version)
    path.chomp
  end
end

module Gem
  class Faker
    def respond_to?(ivar)
      instance_variable_defined?("@#{ivar}") || super
    end

    def method_missing(ivar, *args)
      respond_to?(ivar) ? instance_variable_get("@#{ivar}") : super
    end
  end

  class Dependency < Faker
    def tweedle
      if respond_to?(:version_requirements)
        version_requirements.requirements[0].first
      elsif respond_to?(:requirement)
        requirement.requirements[0].first
      end
    end

    def version
      version_requirements.requirements[0].last.version
    end
  end
  class Specification < Faker; end
  class Requirement   < Faker; end
  class Version       < Faker; end
end

def rpg_dependencies(name, version)
  deps = rpg("unpack", "-c", "-m", name, version)
  return [] unless $?.success?

  deps = YAML.load(deps)
  deps = deps.dependencies

  deps.map do |dep|
    dep_line(dep.name, dep.tweedle, dep.version)
  end
end

version ||= list(source)

package_path = "#{Rip.packages}/#{source}-#{Rip.md5("#{source}#{version}")}"

synchronize(package_path) do
  if File.directory?(package_path)
    puts package_path
    exit 0
  end

  cd Rip.packages

  path = unpack(source, version)

  if !File.exist?(path)
    abort "#{source} #{version} not found"
  end

  mv path, package_path

  File.open("#{package_path}/metadata.rip", 'w') do |f|
    f.puts "#{source} #{version}"
  end

  if !File.exists?(deps_rip = "#{package_path}/deps.rip")
    deps = dependencies(source, version)

    if deps.any?
      File.open(deps_rip, 'w') do |f|
        f.puts deps.sort.join("\n")
      end
    end
  end

  puts package_path
end
