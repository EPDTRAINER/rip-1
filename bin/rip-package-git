#!/usr/bin/env ruby
# Usage: rip-package-git URL VERSION

source  = ARGV[0]
version = ARGV[1] || "master"

unless source =~ %r{^file://|^git://|\.git$} ||
    File.directory?(source) && File.exists?("#{source}/HEAD")
  exit 3 # Can't handle source
end


require 'rip/script'

def parse_git_rev(path, rev)
  ref = git "--git-dir=#{path} rev-parse --verify --quiet #{rev}"
  $?.success? ? ref : nil
end

def fixed_rev?(path, rev, ref)
  ref =~ /^#{rev}/ || # substring of ref
    git("--git-dir=#{path} tag -l #{rev}") == rev # tag
end


if source =~ /([^\/]+?)-.{32}/
  name = $1
else
  name = source.split(%r{:|/}).last.chomp('.git')
end

ref = nil
cache_path = "#{Rip.cache}/#{name}-#{Rip.md5(source)}"


synchronize(cache_path) do
  # Cache exists and we have a fixed reference
  if File.directory?(cache_path)
    ref = parse_git_rev(cache_path, version)
    ref = nil if !fixed_rev?(cache_path, version, ref)
  end

  # Update cache and deference
  if !ref
    if File.directory?(cache_path)
      git "--git-dir=#{cache_path} fetch -q"
    elsif !git("clone --bare --mirror #{source} #{cache_path}")
      abort "#{source} not found"
    end

    ref = parse_git_rev(cache_path, version)
  end

  if !ref
    abort "#{source} #{version} could not be found"
  end
end


package_path = "#{Rip.packages}/#{name}-#{Rip.md5("#{source}#{ref}")}"

synchronize(package_path) do
  if File.directory?(package_path)
    puts package_path
    exit 0
  end

  git("clone #{source} #{package_path}") || exit(1)
  cd package_path
  git "checkout --quiet #{ref}"
  git "remote rm origin"
  git "branch -D master"

  File.open("#{package_path}/metadata.rip", 'w') do |f|
    f.puts "#{source} #{ref}"
  end

  puts package_path
end
