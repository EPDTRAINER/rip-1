#!/usr/bin/env ruby
# Usage: rip-package-git URL VERSION

source  = ARGV[0]
version = ARGV[1] || "master"

unless source =~ %r{^file://|^git://|\.git$} ||
    File.directory?(source) && File.exists?("#{source}/HEAD")
  exit 3 # Can't handle source
end


require 'rip/script'

def parse_git_rev(path, rev)
  if tag?(path, rev)
    rev
  else
    ref = git "--git-dir=#{path} rev-parse --verify --quiet #{rev}"
    $?.success? ? ref : nil
  end
end

def tag?(path, name)
  git("--git-dir=#{path} tag -l #{name}") == name
end


if source =~ /([^\/]+?)-.{32}/
  name = $1
else
  name = source.split(%r{:|/}).last.chomp('.git')
end

ref = nil
cache_path = "#{Rip.cache}/#{name}-#{Rip.md5(source)}"


synchronize(cache_path) do
  # Cache exists and we have a (partial?) SHA - grab the full thing
  if File.directory?(cache_path) && ref =~ /^#{version}/
    ref = parse_git_rev(cache_path, version)
  end

  # Update cache and deference
  if !ref
    if File.directory?(cache_path)
      info "updating #{source}"
      git "--git-dir=#{cache_path} fetch -q 2> /dev/null"
    else
      info "fetching #{source}"
      git("clone --bare --mirror #{source} #{cache_path} 2> /dev/null") ||
        abort("#{source} not found")
    end

    ref = parse_git_rev(cache_path, version)
  end

  if !ref
    abort "#{source} #{version} could not be found"
  end
end


package_path = "#{Rip.packages}/#{name}-#{Rip.md5("#{source}#{ref}")}"

synchronize(package_path) do
  if File.directory?(package_path)
    puts package_path
    exit 0
  end

  git("clone #{source} #{package_path} 2> /dev/null") || exit(1)
  cd package_path
  git "checkout --quiet #{ref}"
  git "remote rm origin"
  git "branch -D master"

  File.open("#{package_path}/metadata.rip", 'w') do |f|
    f.puts "#{source} #{ref}"
  end

  puts package_path
end
